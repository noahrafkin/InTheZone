#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftFront,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           leftRear,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightRear,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Mlift1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Mlift2,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//initalizing variables
int Fast = 127;
int Medium = 63;
int Slow = 30;
void moveF(int cent) //Defines my Function 'MoveF' and sets a parameter 'Cent' or Centimeters
{
   resetMotorEncoder(rightFront);
 resetMotorEncoder(leftFront);
 float EncoderCounts = cent/31.91 * 627.2;
   //Defines the Float EncoderCounts as
	//Distance in Centimeters I want to go/Circumfrence of your wheel * 360
	//equals the distance you want to go
	while (nMotorEncoder[leftFront] < EncoderCounts) //Sets a while loop that will run until the left motor encoder has a greater value then 'EncoderCounts'
	{
		if(nMotorEncoder[leftFront] > nMotorEncoder[rightFront])
		{
			  motor[leftFront] = Medium - 5; //While the loop is running sets all motors to forward
		motor[rightFront] = Medium;
		motor[rightRear] = Medium;
		motor[leftRear] = Medium - 5;
}
	if(nMotorEncoder[rightFront] > nMotorEncoder[leftFront])
		{
			  motor[leftFront] = Medium ; //While the loop is running sets all motors to forward
		motor[rightFront] = Medium - 5;
		motor[rightRear] = Medium- 5;
		motor[leftRear] = Medium;
}
  	if(nMotorEncoder[leftFront] == nMotorEncoder[rightFront])
  	{
	  motor[leftFront] = Medium; //While the loop is running sets all motors to forward
		motor[rightFront] = Medium;
		motor[rightRear] = Medium;
		motor[leftRear] = Medium;
	}
}
}
//The MoveUp Function
void moveUp( int time)
 {
   motor[Mlift1] = -127;
   motor[Mlift2] = -127;
 wait1Msec(time);
   }

if (true){
void moveDown( int time)
 {
   motor[Mlift1] = 127;
   motor[Mlift2] = 127;
 wait1Msec(time);
   }
 void turnR(int Encoders)
 {
  resetMotorEncoder(rightFront);
 resetMotorEncoder(leftFront);
 while (nMotorEncoder[rightFront] < Encoders)
   {
      motor[leftFront] = -Medium; //While the loop is running sets all motors to forward
		motor[rightFront] = Medium;
		motor[rightRear] = Medium;
		motor[leftRear] = -Medium;
 }
}
void moveBack(int time)
{
	motor[leftFront] = -Medium; //While the loop is running sets all motors to forward
		motor[rightFront] = -Medium;
		motor[rightRear] = -Medium;
		motor[leftRear] = -Medium;
  wait1Msec(time)
}
task main()
{


while(1==1)
	{
	if(vexRT[Btn8U] == 1)
	{
		motor[Mlift1] = 127;
		motor[Mlift2] = 127;
	}

	else if(vexRT[Btn8L] == 1)
	{
		motor[Mlift1] = -127;
		motor[Mlift2] = -127;
	}

	else
	{
			motor[Mlift1] = 0;
		motor[Mlift2] = 0;
	}

   if(vexRT[Btn7U] == 1)
   {
     moveF(90);
moveUp(1000);
turnR(1200);
moveF(135);
moveDown(1000);
moveBack(1000);
}
		motor[leftFront] = 	vexRT[Ch2] + vexRT[Ch1];
		motor[rightFront] =  vexRT[Ch2] +  -vexRT[Ch1];
		motor[leftRear] =  vexRT[Ch2]  + vexRT[Ch1];
		motor[rightRear]= vexRT[Ch2] + -vexRT[Ch1];
	}
}
